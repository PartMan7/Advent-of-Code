exports.runs = 1000;

exports.solve = function (fileString) {
	const input = (input => ![input.addToQueue = (estimate, time, pos, force, flag) => (found => (found >= 0 && flag) ? (term => input.addToQueue(term.estimate, term.time, term.pos, true))(input.queue.splice(found, 1)[0]) : input.queue.splice(input.queue.findLastIndex(term => (term.estimate !== estimate) ? term.estimate < estimate : term.time >= time) + 1, 0, { estimate, time, pos }))(force ? -1 : input.queue.findIndex(term => (term.pos[0] === pos[0] && term.pos[1] === pos[1]) ? (term.time === time) ? true : (term.time > time) ? [term.estimate -= (term.time - time), term.time = time, flag = true] : false : false)), input.h = input.height - 2, input.w = input.width - 2, input.run = (t0, t1) => ((done, ans) => ![Array.from({ length: 100_000 }).find(() => (next => (doneStr => (done[doneStr]) ? null : (coveredMap => (ans = [[-1, 0], [0, 1], [1, 0], [0, -1], [0, 0]].reduce((acc, [i, j], k) => acc || (([x, y]) => (!((x === 0 && y === 1) || (x === input.h + 1 && y === input.w)) && (x <= 0 || x >= input.h + 1 || y <= 0 || y >= input.w + 1 || coveredMap[`${x}|${y}`])) ? false : (x === t0 && y === t1) ? next.time + 2 : ![(args => done[args.join(',')] || input.addToQueue(...args))([next.time + 1 + Math.abs(t0 - x) + Math.abs(t1 - y), next.time + 1, [x, y]])])([next.pos[0] + i, next.pos[1] + j]), null)) || ![done[doneStr] = true])(input.getMap(next.time + 1)))(Object.values(next).flat().join(',')))(input.queue.shift()))] || ans)({})] || input)((lines => ({ height: lines.length, width: lines[0].length, blizzards: lines.reduce((bs, row, i) => [...bs, ...row.reduce((acc, cell, j) => '^>v<'.includes(cell) ? [...acc, { pos: [i, j], move: [[-1, 0], [0, 1], [1, 0], [0, -1]]['^>v<'.indexOf(cell)] }] : acc, [])], []), queue: [{ estimate: 0, time: 0, pos: [0, 1] }], cacheMap: [], getMap: t => (input.cacheMap[t]) || (map => input.blizzards.forEach(b => (pos => [pos[0] = 1 + ((pos[0] - 1) % input.h + input.h) % input.h, pos[1] = 1 + ((pos[1] - 1) % input.w + input.w) % input.w, map[`${pos[0]}|${pos[1]}`] = true])(b.pos.slice().map((v, i) => v + t * b.move[i]))) || map)(input.cacheMap[t] = {}) }))(fileString.trim().split('\n').map(r => r.split('').map(c => c === '.' ? null : c))));
	const ans1 = input.run(input.h, input.w);
	const ans2 = ![input.queue = [{ time: ans1, pos: [input.h + 1, input.w] }], input.queue = [{ time: input.run(1, 1), pos: [0, 1] }]] || input.run(input.h, input.w);
	return [ans1, ans2];
};
