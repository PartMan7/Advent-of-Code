exports.runs = 1;

exports.solve = function (fileString) {
	const input = { jets: fileString.trim().split('').map(char => ({ '>': 1, '<': -1 })[char]), rocks: `####\n\n.#.\n###\n.#.\n\n..#\n..#\n###\n\n#\n#\n#\n#\n\n##\n##`.split('\n\n').map(rock => rock.split('\n').map(line => line.split('').map(c => Number(c === '#')))).map(rock => Array.from({ length: rock.length }).map((_, i) => rock[rock.length - 1 - i].map((c, j) => c ? [[i, j]] : []).flat()).flat()), j: 0, cave: [['+', ...Array(7).fill('-'), '+']], slice: () => ['|', ...Array(7).fill(''), '|'], peak: 0, jetCount: 0, collision: (rock, left, bot, skip) => left <= 0 || rock.some(([i, j]) => input.cave[bot + i]?.[left + j]), placeRock: (j, header, lines, skip) => ((While, rock, bot, left) => While(() => true, () => (newLeft => ![input.collision(rock, newLeft, bot) ? null : (left = newLeft), bot--] || (input.collision(rock, left, bot)) ? ![bot++, input.peak = Math.max(input.peak, Math.max(...rock.map(([i]) => bot + i))), While(() => input.cave.length <= input.peak + 7, () => input.cave.push(input.slice())), rock.forEach(([i, j]) => input.cave[bot + i][left + j] = '#')] || ['exit'] : null)(left + input.jets[input.jetCount++ % input.jets.length])))((While => While = (cond, code) => !cond() || (code()?.[0] === 'exit' ? null : While(cond, code)))(), input.rocks[j % input.rocks.length], input.peak + 4, 3) ||  header ? (tip => Array.from({ length: lines + 3 - skip - 1 }).reduce((a, v, I) => a ?? (i => ![tip += '\n' + input.cave[input.cave.length - 1 - i].map(c => c || '.').join('')] || (tip.length > header.length) ? tip.startsWith(header) : (header.startsWith(tip) ? null : false))(I + skip + 1), null))(input.cave.at(-skip - 1).map(c => c || '.').join('')) : null };
	const ans1 = ![Array.from({ length: 7 }).forEach(() => input.cave.push(input.slice())), Array.from({ length: 2022 }).forEach(() => input.placeRock(input.j++))] || input.peak;
	const ans2 = ![(While => [While(() => input.j < (input.jets.length > 1000 ? input.jets.length : (input.jets.length * 10)), () => input.placeRock(input.j++)), (str => (repeat => (rawHeader => (skip => (header => (linesToCheck => [[input.anchorJ = input.j, input.anchorPeak = input.peak], Array.from({ length: repeat[0].split('\n').length / 2 }).forEach(() => input.placeRock(input.j++)), While(() => !input.placeRock(input.j++, header, linesToCheck, skip), () => null)])(header.split('\n').length + repeat[0].split('\n').length))(rawHeader.substr(skip * 10)))(rawHeader.match(/\|\.{7}\|/g).length))(str.substr(0, repeat.index) + repeat[0]))(str.match(/((?:\|[#\.]{7}\|\n){10,}?)(?=\1{3})/)))(input.cave.map(row => row.map(c => c || '.').join('')).reverse().join('\n')), [input.deltaJ = input.j - input.anchorJ, input.deltaPeak = input.peak - input.anchorPeak], While(() => (1000000000000 - input.j) % input.deltaJ !== 0, () => input.placeRock(input.j++))])((While => While = (cond, code) => !cond() || (code()?.[0] === 'exit' ? null : While(cond, code)))())] || input.peak + (1000000000000 - input.j) / input.deltaJ * input.deltaPeak;
	return [ans1, ans2];
};
