exports.runs = 10;

exports.solve = function (fileString) {
	const input = (input => ![input.weightedNodes = Object.keys(input.info).filter(node => input.info[node].flow), input.dist = (nodes => (dist => nodes.forEach(node => [dist[node] = {}, nodes.forEach(n => [dist[node][n] = Infinity, (node === n) && (dist[node][n] = 0)]), input.info[node].to.forEach(e => (dist[node][e] = 1))]) || nodes.forEach(k => nodes.forEach(i => nodes.forEach(j => (dist[i][k] + dist[k][j] < dist[i][j]) && (dist[i][j] = dist[i][k] + dist[k][j])))) || dist)({}))(Object.keys(input.info))] || input)({ info: Object.fromEntries(fileString.trim().split('\n').map(line => [line.substr(6, 2), { flow: ~~line.substr(23).split(';')[0], to: line.split(/valves? /)[1].split(', ') }])), toExplore: [{ node: 'AA', weight: 0, timeLeft: 30, visited: new Set() }], max: 0, cache: {} });
	const ans1 = !Array.from({ length: 500_000 }).some(() => (input.toExplore.length === 0) || (({ node, weight, timeLeft, visited, path }) => ![(input.max < weight) && (input.max = weight), (timeLeft <= 1) || input.weightedNodes.forEach(neighbor => (visited.has(neighbor)) || (time => (time < 0) || ((wt, set) => [set.add(neighbor), input.toExplore.splice(input.toExplore.findLastIndex(term => term.weight <= wt) + 1, 0, { node: neighbor, weight: wt, timeLeft: time, visited: set })])(weight + time * input.info[neighbor].flow, new Set(visited)))(timeLeft - input.dist[node][neighbor] - 1))])(input.toExplore.pop())) || input.max;
	const ans2 = ![(getBest => getBest = (current, timeLeft, flow, opened) => (canOpen => (![(curStr => (!input.cache[curStr] || input.cache[curStr] < flow) && (input.cache[curStr] = flow))(input.weightedNodes.filter(node => opened[node]))] || Math.max(...canOpen.map(toOpen => (timeLeft - input.dist[current][toOpen] - 1 <= 0) ? 0 : input.info[toOpen].flow * (timeLeft - input.dist[current][toOpen] - 1) + getBest(toOpen, timeLeft - input.dist[current][toOpen] - 1, input.info[toOpen].flow * (timeLeft - input.dist[current][toOpen] - 1) + flow, { ...opened, [toOpen]: true })))))(input.weightedNodes.filter(node => !opened[node])))()('AA', 26, 0, {}), (fill => fill = cur => (str => input.cache[str] || (input.cache[str] = Math.max(...cur.map(v => fill(cur.filter(n => n !== v))))))(cur.join(',')))()(input.weightedNodes)] || Math.max(...Object.keys(input.cache).map(h => h ? (hN => hN.size === input.weightedNodes.length ? 0 : input.cache[h] + input.cache[input.weightedNodes.filter(node => !hN.has(node)).join(',')])(new Set(h.split(','))) : 0));
	return [ans1, ans2];
};
