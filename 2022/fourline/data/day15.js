exports.runs = 10;

exports.solve = function (fileString) {
	const input = (manhattan => ({ lines: fileString.trim().split('\n').map(line => line.split(':').map(str => str.match(/-?\d+/g).map(match => ~~match))).map(([sensor, beacon]) => ({ sensor, beacon, range: manhattan(sensor, beacon) })), unifier: () => ({ ranges: [], add: (THIS, range) => (index => [THIS.ranges.splice(index, 0, range), THIS.sweepHigh(THIS, index + 1 - THIS.sweepLow(THIS, index))])(THIS.ranges.findLastIndex(term => term[0] <= range[0]) + 1), sweepLow: (THIS, i) => i === 0 ? 0 : ((THIS.ranges[i][0] <= THIS.ranges[i - 1][1] + 1) ? (![THIS.ranges[i - 1][1] = Math.max(THIS.ranges[i][1], THIS.ranges[i - 1][1]), THIS.ranges.splice(i, 1)] || 1) : 0), sweepHigh: (THIS, i) => (i >= THIS.ranges.length) || (toRemove => [THIS.ranges.find(() => (THIS.ranges[i - 1][1] >= THIS.ranges[i + toRemove]?.[0] - 1) ? (toRemove++ && false) : true), THIS.ranges[i - 1][1] = Math.max(THIS.ranges[i + toRemove - 1][1], THIS.ranges[i - 1][1]), THIS.ranges.splice(i, toRemove)])(0), noGaps: (THIS, anchor) => (loc => loc && loc[0] <= anchor[0] && anchor[1] <= loc[1])(THIS.ranges.find(term => term[0] <= anchor[0] && anchor[0] <= term[1])) }) }))((point1, point2) => Math.abs(point2[0] - point1[0]) + Math.abs(point2[1] - point1[1]));
	const ans1 = ((unifier, beacons) => (![input.lines.forEach(({ beacon }) => (beacon[1] === 2000000) && beacons.add(beacon[0])), input.lines.forEach(point => (spare => (spare >= 0) ? unifier.add(unifier, [point.sensor[0] - spare, point.sensor[0] + spare]) : null)(point.range - Math.abs(2000000 - point.sensor[1])))] && false) || unifier.ranges.reduce((acc, [from, to]) => acc + to - from + 1, 0) - beacons.size)(input.unifier(), new Set());
	const ans2 = Array.from({ length: 4000000 + 1 }).reduce((acc, _, i) => acc ?? (list => (![input.lines.forEach(point => (spare => (spare >= 0) ? list.add(list, [point.sensor[0] - spare, point.sensor[0] + spare]) : null)(point.range - Math.abs(i - point.sensor[1])))] || null) ?? (list.noGaps(list, [0, 4000000]) ? null : (list.ranges.find(t => t[1] > 0)[1] + 1) * 4000000 + i))(input.unifier()), null);
	return [ans1, ans2];
};
